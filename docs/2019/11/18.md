---
title: 用nodejs来提供一个简单接口
tag: nodejs
---

平时经常都是使用express或koa框架直接进行后台开发，但是这次需求只是提供一个简单的接口，所以就选择使用nodejs直接创建服务器


## 创建node服务器

服务器文件 server.js
```js
const http = require('http')
const fs = require('fs')
const querystring = require('querystring')
const server = http.createServer()
const router = require('./router')

const Route = new router([
    "/signTransaction",
])

server.on('request',function(req,res){
    try {
        var param = ''
        req.on('data', function (chunk) {
            param += chunk;
        });
        req.on('end', function () {
            param = querystring.parse(param);
            var request = {
                url: req.url,
                method: req.method,
                param: param
            }
            var result = Route.judgeUrl(request,res)
        });
    } catch (error) {
        console.log(error)
    }
})

process.on('uncaughtException', function (err) {
    //打印出错误
    console.log(err);
    //打印出错误的调用栈方便调试
    console.log(err.stack);
});

server.listen(8888, function(){
    console.log('running on port 8888....')
})

```
> 因为post请求的参数是放在请求体里面，所以需要对请求进行监听并收集chunk数据，直到请求结束再重新解析处理。

路由 router.js
```js
const fs = require('fs')
const path = require('path')
const transaction = require('./Transaction')

class router{
    constructor(list){
        this.route_list = list
    }

    judgeUrl(req, res){
        if(req.param.token !== '0dxe1d21d2fqd'){
            res.writeHead(200,{'Content-Type':'text/plain; charset=utf-8'}).end('Verification failed ')
            return 
        }else if(req.method != 'post'){
            res.writeHead(200,{'Content-Type':'text/plain; charset=utf-8'}).end('Request type error, please use post instead ')
            return
        }else if(this.router_list.indexOf(req.url) < 0){
            res.writeHead(200,{'Content-Type':'text/plain; charset=utf-8'}).end('Api URL is not correct,please check again ')
            return
        }else{
            switch(req.url){
                case '/signTransaction':
                    this.trans(req, res);
                    break;
            }
        }
    }

    trans(req, res){
        res.writeHead(200,{'Content-Type':'application/json; charset=utf-8'})
        var trans = JSON.parse(req.param.trans)
        try {
            var transHash = transaction(req.param.key)(trans)
        } catch (error) {
            res.end(JSON.stringify(error))
            return
        }
        res.end(JSON.stringify(transHash))
    }
}
module.exports = router
```

测试 test.js

- 准备数据和接口参数
```js
var transaction = {
    "locks": {
        "args": "0xdde7801c073dfb3464cssdbb84e99",
        "math_hash": "0x9bd7e06f3ecf4be0f2fcddfdseere",
        "hashType": "type"
    }
}
var key = '0xsfd55seeeeee'
var qs = require('querystring'); 
var post_data = { trans:JSON.stringify(transaction),key:key }
var content = qs.stringify(post_data);  
var options = {
    hostname: '127.0.0.1',  
    port: 8888,  
    path: '/signTransaction',  
    method: 'POST',  
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8'  
    }
};
```

- 发送http请求
```js
var http = require('http');
var req = http.request(options, function (res) {
    res.setEncoding('utf8');
    res.on('data', function (chunk) {  
        console.log('BODY: ' + chunk);  
    });
});  
req.on('error', function (e) {
    console.log('problem with request: ' + e.message);  
});  
// write data to request body  
req.write(content);
req.end();  
```

> 需要注意的是，这里对于请求对象要进行url转码，因为在网络传输过程中，浏览器并不会直接传递对象，而是字符，所以要使用qs.stringify()将对象 序列化成URL的形式，以&进行拼接。


#### post请求的两种content-type 区别
- request.ContentType = "application/json; charset=utf-8";
`{ Name : 'John Smith', Age: 23}`

- request.ContentType = "application/x-www-form-urlencoded";  
`Name=John+Smith&Age=23`
