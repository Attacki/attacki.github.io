--- 
title: "typescript 当然是前端必备技能"
tag: typescript
---

# TypeScript
在我的印象当中, react和typescript是逼格最高的两个标志. typescript大势所趋, 已经成为了前端必备技能, 做一下学习总结.

#### 类型声明空间和变量声明空间

类型声明空间,指的是可以作为类型注解使用的内容.  如:
```ts

interface Bar {}
let bar: Bar;

```
但是尽管做了声明, Bar却并不能作为变量使用, 因为interface只将它声明在了类型空间中.  
```ts
interface Bar {}
const bar = Bar; // Error: "cannot find name 'Bar'"
```
变量声明空间包含可用作变量的内容, class在类型空间和变量空间都进行了声明, 以下写法是正确的
```
class Foo {}
const someVar = Foo;
let bar:Foo;
```


#### 模块

避免使用全局变量是共识, 文件模块可以避免变量污染.

#### 重写类型的动态查找

```ts
// globals.d.ts
declare module 'foo' {
  // some variable declarations
  export var bar: number;
}
```
declare 模块方便typescript进行查找, 用来解决查找模块路径的问题


#### 命名空间

typescript 的命名空间, 其实就是使用闭包避免变量污染, 两行代码看明白怎么回事, 以下是我们常用的编写方式:
```js
(function(something) {
  something.foo = 123;
})(something || (something = {}));

// ts中命名空间写法
namespace something{
  export foo = 123;
}
// ts编译过后, js内容跟上面写法完全一样
```

#### 基本使用
- 简单的类型声明注解
```ts
const num: number = 123;
let str: string;
let bool: boolean;
function identity(num: number): number {
  return num;
}
identity(sum)
identity(str) //Error
```
- 接口和内联类型注解
```ts
interface Name { // 会对所有的属性进行检查
    name: string
    age:number
}
let name1:Name
let name2:{ 
    name: string
    age:number
};
//  这里name1和name2的类型声明性质是一样的， 不过Name提供的是一个接口可以复用
name1 = name2 = {
    name: 'john',
    age: 13
}
```
- 特殊类型
在typescript中特殊类型有any、null、undefined，这三种类型没有什么区别都可以赋予任意类型的变量。  
使用 :void 来表示一个函数没有一个返回值
```ts
function log(message: string): void {
  console.log(message);
}
```


- 泛型
在计算机科学中。许多算法和数据解构并不会依赖于对象的实际类型。
```ts
// <>中的T表示的为该函数提供的类型参数
function reverse<T>(items: T[]): T[] {
    const toreturn = [];
    for (let i = items.length - 1; i >= 0; i--) {
      toreturn.push(items[i]);
    }
    return toreturn;
}
  
const sample = [1, 2, 3];
let reversed = reverse(sample);

console.log(reversed); // 3, 2, 1
```
- 联合类型  
希望属性为多种属性的时候，可以使用联合类型
```ts
function formatCommandline(command: string[] | string) {
  let line = '';
  if (typeof command === 'string') {
    line = command.trim();
  } else {
    line = command.join(' ').trim();
  }
}
```
- 交叉类型
```ts
function extend<T, U>(first: T, second: U): T & U {
  const result = <T & U>{};
  for (let id in first) {
    (<T>result)[id] = first[id];
  }
  for (let id in second) {
    if (!result.hasOwnProperty(id)) {
      (<U>result)[id] = second[id];
    }
  }

  return result;
}
const x = extend({ a: 'hello' }, { b: 42 });
// 现在 x 拥有了 a 属性与 b 属性
```
- 元组类型
```ts
let nameNumber: [string, number];
nameNumber = ['Jenny', 322134];
```
- 类型别名
```ts
type Text = string | { text: string };
type Coordinates = [number, number];
type Callback = (data: string) => void;
type StrOrNum = string | number;
// 使用
let sample: StrOrNum;
sample = 123;
sample = '123';
```
> 如果你需要使用类型注解的层次结构，请使用接口。它能使用 implements 和 extends  
> 为一个简单的对象类型（如上面例子中的 Coordinates）使用类型别名，只需要给它一个语义化的名字即可。另外，当你想给联合类型和交叉类型提供一个语义化的名称时，一个类型别名将会是一个好的选择。



