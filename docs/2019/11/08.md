---
title: 虚拟dom
tag: vue
---
# SnabbdomJS
Vuejs就是借鉴这个项目来构建虚拟dom的，希望可以对typescript和vnode更加熟悉，为探索Vuejs源码做铺垫。   
在虚拟dom中，所有的属性和处理都是对象，在进行新旧节点对比的时候，也就是对象的对比，根据对比结果再更新再真实的dom上。
虚拟dom就是在js中的模拟真实dom中，比如class，元素属性（如video的muted属性等）、自定义属性（data-*），事件监听器（负责函数回调与事件更新），style属性及props属性等等

## 主逻辑
```ts
/* global module, document, Node */
import {Module} from './modules/module';
import {Hooks} from './hooks';
import vnode, {VNode, VNodeData, Key} from './vnode';
import * as is from './is';
import htmlDomApi, {DOMAPI} from './htmldomapi';

function isUndef(s: any): boolean { return s === undefined; }
function isDef(s: any): boolean { return s !== undefined; }

type VNodeQueue = Array<VNode>;

const emptyNode = vnode('', {}, [], undefined, undefined);

function sameVnode(vnode1: VNode, vnode2: VNode): boolean {
  return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
}

function isVnode(vnode: any): vnode is VNode {
  return vnode.sel !== undefined;
}

type KeyToIndexMap = {[key: string]: number};

type ArraysOf<T> = {  //其实这个声明的意思就是将T的类型声明全部提取出来，并且变为数组类型，数组子项仍然为T对应属性的类型
  [K in keyof T]: (T[K])[]; // 从T中取出所有属性，改为对应类型的数组
}

type ModuleHooks = ArraysOf<Module>;

function createKeyToOldIdx(children: Array<VNode>, beginIdx: number, endIdx: number): KeyToIndexMap {
  let i: number, map: KeyToIndexMap = {}, key: Key | undefined, ch;
  for (i = beginIdx; i <= endIdx; ++i) {
    ch = children[i];
    if (ch != null) {
      key = ch.key;
      if (key !== undefined) map[key] = i;
    }
  }
  return map;
}

const hooks: (keyof Module)[] = ['create', 'update', 'remove', 'destroy', 'pre', 'post'];

export {h} from './h';
export {thunk} from './thunk';
// Partial表示可选的
export function init(modules: Array<Partial<Module>>, domApi?: DOMAPI) {
  let i: number, j: number, cbs = ({} as ModuleHooks);  // 这里的cbs代表的是

  const api: DOMAPI = domApi !== undefined ? domApi : htmlDomApi;

  for (i = 0; i < hooks.length; ++i) {  // 将modules中的所有对应钩子函数都装在回调列表cbs里面
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      const hook = modules[j][hooks[i]];
      if (hook !== undefined) {
        (cbs[hooks[i]] as Array<any>).push(hook);
      }
    }
  }

  // 创建空的虚拟节点
  function emptyNodeAt(elm: Element) {  
    const id = elm.id ? '#' + elm.id : '';
    const c = elm.className ? '.' + elm.className.split(' ').join('.') : '';
    return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);
  }

  // 删除dom元素节点
  function createRmCb(childElm: Node, listeners: number) {  
    return function rmCb() {
      if (--listeners === 0) {
        const parent = api.parentNode(childElm);
        api.removeChild(parent, childElm);
      }
    };
  }

  // 根据虚拟节点创建element
  function createElm(vnode: VNode, insertedVnodeQueue: VNodeQueue): Node {
    let i: any, data = vnode.data;
    if (data !== undefined) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode); // 调用init钩子函数
        data = vnode.data;  // 更新当前作用域的data
      }
    }
    let children = vnode.children, sel = vnode.sel;
    if (sel === '!') {
      if (isUndef(vnode.text)) {
        vnode.text = '';
      }
      vnode.elm = api.createComment(vnode.text as string);
    } else if (sel !== undefined) {
      // sel的格式如： div#select.zone.checked
      const hashIdx = sel.indexOf('#');
      const dotIdx = sel.indexOf('.', hashIdx);
      const hash = hashIdx > 0 ? hashIdx : sel.length;
      const dot = dotIdx > 0 ? dotIdx : sel.length;
      const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;
      const elm = vnode.elm = isDef(data) && isDef(i = (data as VNodeData).ns) ? api.createElementNS(i, tag)
                                                                               : api.createElement(tag);
      if (hash < dot) elm.setAttribute('id', sel.slice(hash + 1, dot)); //为节点添加id属性
      if (dotIdx > 0) elm.setAttribute('class', sel.slice(dot + 1).replace(/\./g, ' '));//为节点添加class列表
      for (i = 0; i < cbs.create.length; ++i) cbs.create[i](emptyNode, vnode);  //调用各个属性（class，props，style等）的create钩子函数 
      if (is.array(children)) { // 如果有子节点，就要对子节点列表进行遍历
        for (i = 0; i < children.length; ++i) {
          const ch = children[i];
          if (ch != null) { 
            // 然后就在当前节点里面，追加子节点咯
            api.appendChild(elm, createElm(ch as VNode, insertedVnodeQueue));
          }
        }
      } else if (is.primitive(vnode.text)) {
        // 文本节点直接追加
        api.appendChild(elm, api.createTextNode(vnode.text));
      }
      i = (vnode.data as VNodeData).hook; // 这里的i覆盖了前面的i
      if (isDef(i)) {
        if (i.create) i.create(emptyNode, vnode);   // 调用节点的create钩子
        if (i.insert) insertedVnodeQueue.push(vnode);   // 如果有insert钩子，就把该节点放进有insert钩子函数的节点列表
      }
    } else {
      vnode.elm = api.createTextNode(vnode.text as string);
    }
    return vnode.elm;
  }

  // 为elm追加，元素的vnodes数组中指定数量的child_element
  function addVnodes(parentElm: Node,
                     before: Node | null,
                     vnodes: Array<VNode>,
                     startIdx: number,
                     endIdx: number,
                     insertedVnodeQueue: VNodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      const ch = vnodes[startIdx];
      if (ch != null) {
        api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);
      }
    }
  }

  // 调用destory钩子函数
  function invokeDestroyHook(vnode: VNode) {
    let i: any, j: number, data = vnode.data;
    if (data !== undefined) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode);
      for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode);
      if (vnode.children !== undefined) {
        for (j = 0; j < vnode.children.length; ++j) {
          i = vnode.children[j];
          if (i != null && typeof i !== "string") {
            invokeDestroyHook(i);
          }
        }
      }
    }
  }

  // 为elm删除，元素的vnodes数组中指定数量的child_element
  function removeVnodes(parentElm: Node,
                        vnodes: Array<VNode>,
                        startIdx: number,
                        endIdx: number): void {
    for (; startIdx <= endIdx; ++startIdx) {
      let i: any, listeners: number, rm: () => void, ch = vnodes[startIdx];
      if (ch != null) {
        if (isDef(ch.sel)) {
          invokeDestroyHook(ch);  // 为当前节点调用destory钩子
          listeners = cbs.remove.length + 1;
          rm = createRmCb(ch.elm as Node, listeners);
          for (i = 0; i < cbs.remove.length; ++i) cbs.remove[i](ch, rm);
          if (isDef(i = ch.data) && isDef(i = i.hook) && isDef(i = i.remove)) {
            i(ch, rm);  // 调用remove钩子
          } else {
            rm();
          }
        } else { // Text node
          api.removeChild(parentElm, ch.elm as Node);
        }
      }
    }
  }

  // 更新element的子节点
  function updateChildren(parentElm: Node,
                          oldCh: Array<VNode>,
                          newCh: Array<VNode>,
                          insertedVnodeQueue: VNodeQueue) {
    let oldStartIdx = 0, newStartIdx = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];  // 旧节点的第一个子节点
    let oldEndVnode = oldCh[oldEndIdx]; // 旧节点的最后一个子节点
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let oldKeyToIdx: any;
    let idxInOld: number;
    let elmToMove: VNode;
    let before: any;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx]; // 上一波修改，Vnode可能左移了
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx];
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) { // 对比新旧节点的第一个子节点，起始节点位置没有变
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue); //对节点进行深度遍历，直接修改
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) { // 对比新旧节点的最后一个子节点，末尾节点位置没有变
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // 同一个Vnode 右移
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldStartVnode.elm as Node, api.nextSibling(oldEndVnode.elm as Node));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // 同一个Vnode 左移
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        api.insertBefore(parentElm, oldEndVnode.elm as Node, oldStartVnode.elm as Node);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (oldKeyToIdx === undefined) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = oldKeyToIdx[newStartVnode.key as string];
        if (isUndef(idxInOld)) { // 如果在旧节点子列表里面找不到新节点子节点的key，说明是新增节点
          api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node);
          newStartVnode = newCh[++newStartIdx];
        } else {  // 找到了，那就是移位了
          elmToMove = oldCh[idxInOld];  //要移动的elm
          if (elmToMove.sel !== newStartVnode.sel) {  // 选择器发生改变了
            api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm as Node);
          } else {  //选择器没有改变，对elm进行移位
            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined as any;
            api.insertBefore(parentElm, (elmToMove.elm as Node), oldStartVnode.elm as Node);
          }
          newStartVnode = newCh[++newStartIdx]; // 新的起始index
        }
      }
    }
    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
      if (oldStartIdx > oldEndIdx) {
        before = newCh[newEndIdx+1] == null ? null : newCh[newEndIdx+1].elm;
        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
      } else {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
      }
    }
  }

  // 当新旧节点进行更新时，给节点创建补丁
  function patchVnode(oldVnode: VNode, vnode: VNode, insertedVnodeQueue: VNodeQueue) {
    let i: any, hook: any;
    if (isDef(i = vnode.data) && isDef(hook = i.hook) && isDef(i = hook.prepatch)) {
      i(oldVnode, vnode); //调用虚拟节点的prepatch钩子
    }
    const elm = vnode.elm = (oldVnode.elm as Node); // 将新vnode的elm替换为旧的vnode的elm
    let oldCh = oldVnode.children;  // 
    let ch = vnode.children;
    if (oldVnode === vnode) return; // 传递的是同一个虚拟节点
    if (vnode.data !== undefined) {
      for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode); // 调用各个属性的update钩子
      i = vnode.data.hook;
      if (isDef(i) && isDef(i = i.update)) i(oldVnode, vnode);  // 调用虚拟节点的update钩子
    }
    if (isUndef(vnode.text)) {  // 如果新节点的text为空
      if (isDef(oldCh) && isDef(ch)) { //新旧子节点进行对比
        if (oldCh !== ch) updateChildren(elm, oldCh as Array<VNode>, ch as Array<VNode>, insertedVnodeQueue);
      } else if (isDef(ch)) { //新增了子节点
        if (isDef(oldVnode.text)) api.setTextContent(elm, '');  //清空之前elm里面的文本内容
        addVnodes(elm, null, ch as Array<VNode>, 0, (ch as Array<VNode>).length - 1, insertedVnodeQueue); // 为elm添加childElements
      } else if (isDef(oldCh)) { //删除了子节点
        removeVnodes(elm, oldCh as Array<VNode>, 0, (oldCh as Array<VNode>).length - 1);  // 为elm删除childElements
      } else if (isDef(oldVnode.text)) { 
        api.setTextContent(elm, ''); // 那就吧elm的文本清空
      }
    } else if (oldVnode.text !== vnode.text) {
      if (isDef(oldCh)) {
        removeVnodes(elm, oldCh as Array<VNode>, 0, (oldCh as Array<VNode>).length - 1); // 删掉之前节点的子节点
      }
      api.setTextContent(elm, vnode.text as string); // 设置elm的文本为新节点的text
    }
    if (isDef(hook) && isDef(i = hook.postpatch)) {
      i(oldVnode, vnode); // 调用postpatch钩子
    }
  }

  return function patch(oldVnode: VNode | Element, vnode: VNode): VNode {
    let i: number, elm: Node, parent: Node;
    const insertedVnodeQueue: VNodeQueue = []; // 有insert钩子的节点列表
    for (i = 0; i < cbs.pre.length; ++i) cbs.pre[i]();   // 补丁开始打包之前

    if (!isVnode(oldVnode)) { //如果不是虚拟节点就创建一个
      oldVnode = emptyNodeAt(oldVnode);
    }

    if (sameVnode(oldVnode, vnode)) { // 根据key和sel属性判别 新旧节点是否同一个
      patchVnode(oldVnode, vnode, insertedVnodeQueue);
    } else {
      // 如果新旧节点不相同
      elm = oldVnode.elm as Node;
      parent = api.parentNode(elm);

      createElm(vnode, insertedVnodeQueue); //创建新的element

      if (parent !== null) {
        api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm));//将新节点插进旧节点之前
        removeVnodes(parent, [oldVnode], 0, 0); //删除虚拟节点及它的element
      }
    }

    for (i = 0; i < insertedVnodeQueue.length; ++i) {
      // 将所有虚拟节点对应的insert钩子执行
      (((insertedVnodeQueue[i].data as VNodeData).hook as Hooks).insert as any)(insertedVnodeQueue[i]);
    }
    for (i = 0; i < cbs.post.length; ++i) cbs.post[i](); //将post钩子函数执行
    return vnode;
  };
}

```



## 处理节点attr属性
对新旧节点属性进行遍历更新和添加。
```ts
// 更新新旧节点属性
function updateAttrs(oldVnode: VNode, vnode: VNode): void {
  var key: string, elm: Element = vnode.elm as Element,
      oldAttrs = (oldVnode.data as VNodeData).attrs,
      attrs = (vnode.data as VNodeData).attrs;

  if (!oldAttrs && !attrs) return;
  if (oldAttrs === attrs) return;
  oldAttrs = oldAttrs || {};
  attrs = attrs || {};

  // 更新修改的属性， 添加新属性
  for (key in attrs) {
    const cur = attrs[key];
    const old = oldAttrs[key];
    if (old !== cur) {
      if (cur === true) {
        elm.setAttribute(key, "");  // 如果为true就是直接添加上去
      } else if (cur === false) {
        elm.removeAttribute(key);   // 如果为false就是直接删除
      } else {
        elm.setAttribute(key, cur);
      }
    }
  }

  for (key in oldAttrs) {
    if (!(key in attrs)) {
      elm.removeAttribute(key);
    }
  }
}
```

## 处理节点class属性
```ts
type Classes = Record<string, boolean> //键是string，值是布尔, true表示这个class存在，false表示不存在
// 更新class
function updateClass(oldVnode: VNode, vnode: VNode): void {
  var cur: any, name: string, elm: Element = vnode.elm as Element,
      oldClass = (oldVnode.data as VNodeData).class,
      klass = (vnode.data as VNodeData).class;

  if (!oldClass && !klass) return;
  if (oldClass === klass) return;
  oldClass = oldClass || {};
  klass = klass || {};

  for (name in oldClass) {
    if (!klass[name]) {
      elm.classList.remove(name);
    }
  }
  for (name in klass) {
    cur = klass[name];
    if (cur !== oldClass[name]) {
      (elm.classList as any)[cur ? 'add' : 'remove'](name);
    }
  }
}

const classModule = {create: updateClass, update: updateClass} as Module
```

## 处理props属性
```ts
type Props = Record<string, any>;

function updateProps(oldVnode: VNode, vnode: VNode): void {
  var key: string, cur: any, old: any, elm = vnode.elm,
      oldProps = (oldVnode.data as VNodeData).props,
      props = (vnode.data as VNodeData).props;

  if (!oldProps && !props) return;
  if (oldProps === props) return;
  oldProps = oldProps || {};
  props = props || {};

  for (key in oldProps) {
    if (!props[key]) {  //新节点的props值为false，就删掉对应的属性
      delete (elm as any)[key];
    }
  }
  for (key in props) {
    cur = props[key];
    old = oldProps[key];
    if (old !== cur && (key !== 'value' || (elm as any)[key] !== cur)) {  //不处理value属性
      (elm as any)[key] = cur;
    }
  }
}
```


## 处理data-类属性
```ts
type Dataset = Record<string, string>;
const CAPS_REGEX = /[A-Z]/g; // 处理驼峰式属性

function updateDataset(oldVnode: VNode, vnode: VNode): void {
  let elm: HTMLElement = vnode.elm as HTMLElement,
    oldDataset = (oldVnode.data as VNodeData).dataset,
    dataset = (vnode.data as VNodeData).dataset,
    key: string;

  if (!oldDataset && !dataset) return;
  if (oldDataset === dataset) return;
  oldDataset = oldDataset || {};
  dataset = dataset || {};
  const d = elm.dataset; // 指定的HTML元素

  for (key in oldDataset) { //遍历旧节点属性
    if (!dataset[key]) {
      if (d) {
        if (key in d) { // 新节点没有该属性，就在HTML元素上删除
          delete d[key];
        }
      } else {
        elm.removeAttribute('data-' + key.replace(CAPS_REGEX, '-$&').toLowerCase()); // 处理驼峰式属性
      }
    }
  }
  for (key in dataset) {  //遍历新节点属性
    if (oldDataset[key] !== dataset[key]) {
      if (d) {
        d[key] = dataset[key];  //更新为新节点的属性值
      } else {
        elm.setAttribute('data-' + key.replace(CAPS_REGEX, '-$&').toLowerCase(), dataset[key]); //元素还没设置过data-类属性，就添加一个咯
      }
    }
  }
}
```

## 处理节点的事件属性
On 描述的就是事件对象是否符合规则，是否存在
```ts
type On = {
  [N in keyof HTMLElementEventMap]?: (ev: HTMLElementEventMap[N]) => void // [handler,handler]
} & {
  [event: string]: EventListener    //['click','mouseMove']
};
```
函数回调的调用，及事件监听器的生成
```ts
function invokeHandler(handler: any, vnode?: VNode, event?: Event): void {
  if (typeof handler === "function") {
    // 调用回调函数
    handler.call(vnode, event, vnode);
  } else if (typeof handler === "object") {
    if (typeof handler[0] === "function") {
      // 只有一个额外参数的回调
      if (handler.length === 2) {
        handler[0].call(vnode, handler[1], event, vnode);
      } else {  
        // 多个参数的回调
        var args = handler.slice(1);
        args.push(event);
        args.push(vnode);
        handler[0].apply(vnode, args);
      }
    } else { //同一个事件类型，可能绑定了多个回调函数，所以第一个参数可能是数组类型
      // call multiple handlers
      for (var i = 0; i < handler.length; i++) {
        invokeHandler(handler[i], vnode, event);
      }
    }
  }
}

function handleEvent(event: Event, vnode: VNode) {
  var name = event.type,  //事件类型
      on = (vnode.data as VNodeData).on;  //是否绑定有事件

  // call event handler(s) if exists
  if (on && on[name]) { //如果该事件存在就调用咯
    invokeHandler(on[name], vnode, event);
  }
}

function createListener() { // 创建监听函数
  return function handler(event: Event) {
    handleEvent(event, (handler as any).vnode);
  }
}
```
新旧节点事件监听器的更新（包括创建，修改，删除）
```ts
function updateEventListeners(oldVnode: VNode, vnode?: VNode): void {
  var oldOn = (oldVnode.data as VNodeData).on,
      oldListener = (oldVnode as any).listener,
      oldElm: Element = oldVnode.elm as Element,
      on = vnode && (vnode.data as VNodeData).on,
      elm: Element = (vnode && vnode.elm) as Element,
      name: string;

  // optimization for reused immutable handlers
  if (oldOn === on) {
    return;
  }


  if (oldOn && oldListener) { // 如果旧节点绑定的有监听器，删掉不用的监听器
    if (!on) {  //表示新节点没有监听事件，或者没有新节点（表示旧节点删除）
      for (name in oldOn) {
        // 如果oldelement改变了或者事件被移除了，就删掉监听器
        oldElm.removeEventListener(name, oldListener, false);
      }
    } else {  // 创建新节点，并且新节点需要绑定新的事件
      for (name in oldOn) {
        if (!on[name]) { //如果新节点没有对应的事件，就要删除旧节点对应的事件
          oldElm.removeEventListener(name, oldListener, false);
        }
      }
    }
  }

  // add new listeners which has not already attached
  if (on) { //为新节点添加事件监听器
    // 重用之前的监听器或者新建，这样上面对旧节点事件进行的处理就有了意义
    var listener = (vnode as any).listener = (oldVnode as any).listener || createListener(); 
    // 为监听器更新节点
    listener.vnode = vnode; //这里进行了节点的新旧交替。（也就是说如果旧节点存在了事件，就用新节点替换旧节点事件监听的element对象）

    // if element changed or added we add all needed listeners unconditionally
    if (!oldOn) { //如果旧节点没有绑定事件，就要为新节点添加事件监听器
      for (name in on) {
        // add listener if element was changed or new listeners added
        elm.addEventListener(name, listener, false); //第三个参数为true代表在捕获阶段执行，反之在冒泡阶段
      }
    } else {  //如果旧节点绑定了事件，就要为旧节点添加，新节点上新增的事件。
      for (name in on) {
        if (!oldOn[name]) { // 如果旧节点处理器没有该事件，就为该节点添加新的事件
          elm.addEventListener(name, listener, false);
        }
      }
    }
  }
}
```
> 需要注意的点就在于新旧节点监听器所监听的element对象的替换。

##  节点概念描述 Vnode VNodeData Hooks
VNode 包含有选择符，数据，子节点，其他节点，文本，key键

```ts
type Key = string | number;

interface VNode {
  sel: string | undefined;  
  data: VNodeData | undefined;
  children: Array<VNode | string> | undefined;
  elm: Node | undefined;
  text: string | undefined;
  key: Key | undefined;
}

interface VNodeData {
  props?: Props;        // 传递属性
  attrs?: Attrs;        // 节点属性 例如 video的muted
  class?: Classes;      // 类名列表
  style?: VNodeStyle;   // 样式属性
  dataset?: Dataset;    // 设置在节点上的 data-* 类的属性
  on?: On;
  hero?: Hero;
  attachData?: AttachData;
  hook?: Hooks;
  key?: Key;
  ns?: string; // for SVGs
  fn?: () => VNode; // for thunks
  args?: Array<any>; // for thunks
  [key: string]: any; // for any other 3rd party module
}

type VNodeStyle = Record<string, string> & {
  delayed?: Record<string, string>
  remove?: Record<string, string>
}


type PreHook = () => any;    // 初始化之前
type InitHook = (vNode: VNode) => any;   // 初始化的时候
type CreateHook = (emptyVNode: VNode, vNode: VNode) => any;  // 创建实例
type InsertHook = (vNode: VNode) => any; // 插入dom
type PrePatchHook = (oldVNode: VNode, vNode: VNode) => any;  // 制作补丁的时候
type UpdateHook = (oldVNode: VNode, vNode: VNode) => any;    // 更新的时候
type PostPatchHook = (oldVNode: VNode, vNode: VNode) => any; // 打上补丁的之后
type DestroyHook = (vNode: VNode) => any;    // 销毁实例
type RemoveHook = (vNode: VNode, removeCallback: () => void) => any; // 移除
type PostHook = () => any;   // 

interface Hooks {
  pre?: PreHook;
  init?: InitHook;
  create?: CreateHook;
  insert?: InsertHook;
  prepatch?: PrePatchHook;
  update?: UpdateHook;
  postpatch?: PostPatchHook;
  destroy?: DestroyHook;
  remove?: RemoveHook;
  post?: PostHook;
}
```


### 工具函数

```ts
// 根据标签名生成 Element元素
function createElement(tagName: any): HTMLElement {
  return document.createElement(tagName);
}
// 创建一个具有指定的命名空间URI和限定名称的元素。 
// 例如：newdiv = document.createElementNS("http://www.w3.org/1999/xhtml","div");
function createElementNS(namespaceURI: string, qualifiedName: string): Element {
  return document.createElementNS(namespaceURI, qualifiedName);
}
// 创建文本节点
function createTextNode(text: string): Text {
  return document.createTextNode(text);
}
// 创建注释节点
function createComment(text: string): Comment {
  return document.createComment(text);
}
// 将 newNode 插入 referenceNode 的前面 （它俩都是）
function insertBefore(parentNode: Node, newNode: Node, referenceNode: Node | null): void {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node: Node, child: Node): void {
  node.removeChild(child);
}

function appendChild(node: Node, child: Node): void {
  node.appendChild(child);
}

function parentNode(node: Node): Node | null {
  return node.parentNode;
}

function nextSibling(node: Node): Node | null {
  return node.nextSibling;
}

function tagName(elm: Element): string {
  return elm.tagName;
}

function setTextContent(node: Node, text: string | null): void {
  node.textContent = text;
}

function getTextContent(node: Node): string | null {
  return node.textContent;
}

function isElement(node: Node): node is Element {
  return node.nodeType === 1;
}

function isText(node: Node): node is Text {
  return node.nodeType === 3;
}

function isComment(node: Node): node is Comment {
  return node.nodeType === 8;
}
```



### gulp构建的模块
```js
// 8号是入口
(function e(t,n,r){
    function s(o,u){
      if(!n[o]){
        if(!t[o]){
          var a = typeof require=="function"&&require;
          if(!u&&a)return a(o,!0);
          if(i)return i(o,!0);
          var f = new Error ("Cannot find module '"+o+"'");
          throw f.code="MODULE_NOT_FOUND",f
        }
        var l=n[o]={exports:{}};
        t[o][0].call(
          l.exports,
          function(e){
            var n=t[o][1][e];
            return s(n?n:e)
          },l,l.exports,e)
      }
      return n[o].exports
    }
    var i = typeof require=="function"&&require;
    console.log(i)
    for(var o=0;o<r.length;o++) s(r[o]);
    return s
  })(
    {
        1:[function(require,module,exports){module.exports = function h(sel, b, c) {};},{"./is":2,"./vnode":7}],
        2:[function(require,module,exports){module.exports = {array: Array.isArray,primitive: function primitive(s) {return typeof s === 'string' || typeof s === 'number';}};},{}],
        3:[function(require,module,exports){module.exports = { create: updateAttrs, update: updateAttrs };},{}],
        4:[function(require,module,exports){module.exports = { create: updateEventListeners, update: updateEventListeners };},{"../is":2}],
        5:[function(require,module,exports){module.exports = { create: updateStyle, update: updateStyle, destroy: applyDestroyStyle, remove: applyRemoveStyle };},{}],
        6:[function(require,module,exports){module.exports = { init: init };},{"./is":2,"./vnode":7}],
        7:[function(require,module,exports){module.exports = function (sel, data, children, text, elm) {};},{}],
        8:[function(require,module,exports){},{"../../h.js":1,"../../modules/attributes":3,"../../modules/eventlisteners":4,"../../modules/style":5,"../../snabbdom.js":6}]
    },
    {},[8]);
```

